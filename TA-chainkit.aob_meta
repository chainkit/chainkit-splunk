{"basic_builder": {"appname": "TA-chainkit", "friendly_name": "Chainkit", "version": "1.0.0", "author": "PencilDATA", "description": "", "theme": "#65A637", "large_icon": "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", "small_icon": "iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAYAAADhAJiYAAAEHElEQVRYR+2YWyimWxjHfxokp73bZpQbOxeUmKKNzBiSciGH5CwZXDjlgkxOE3MhyllSTpGUwwU5bY2M0b5gLhxyyM6ebHsXNZfKBeMUds/a+9VnZvsYn5lxYd28fe9637V+6/88z3+t7zXijjWjO8aDLpAJ4ANYfmPII+AdsCfz6gLVAznfGEabbgwIB040oB+Bv4CfvhPQCeAG/K4B/Qz8CUjYvlcLAH67B9Ij/71CV+Xm9RXKzMxkcnKSjY2NzwY1NTXl5cuXlJeXc3x8fN7/8OFDkpOTqampUffs7OxISEigp6cHT09PRkdHPx3r+kCDg4PU1dUxMzPzGZCFhQWzs7N4eHhwcHBw3u/g4EBXVxd+fn7qnrOzMy0tLRQWFlJQUEB4uNjOhXY7QGZmZjQ2NpKVlcXRkZjuv+1TIHt7e7KzsxkYGLgZkImJCUZGRmoSTaGFhYVzFczNzdnf3+fs7OzCMiWEJycnCICuQtpDT548+XKgR48eMTExwYMHDwgMDFRSS2icnJzw9/fH19eX2tpa+vr6KCoqUhPL6isqKnBxcWF1dZXS0lJ1PyAggN7eXqqqqkhNTWV7exvJSXm/rKxMdzGXhywxMZH4+HilQH9/PzExMWxtbfH48WMVHhlwZGSEnJwclSNv374lODiYubk5iouLVZ4EBQXR3t6unm1tbVUwzc3NNDU18eLFC9LT01leXr4eUH5+Ph8/fmR3dxcrKyulSn19PZGRkSqBZfCoqChev36twMfGxhTQ0NAQPj4+SGilX0Ak3BJe6btxUguQwOzt7WFtbf2/QAI3Pj6uF0gApPLy8vKUJRgM9OHDBywtLZUyUvZylbC4uroqf5mamiIiIuJShUSVnZ0dnj17hqOjo+FAEm9pWpVpQJLw3d3dPH36FDc3t0uBlpaWePPmDWFhYYb5kBayjo4OVfpSJZpCkkPe3t68f/+epKQkvSEbHh7m9PQUd3d35UsGh0zkFguQStKSen5+XpV4SEiIsn99Sd3W1oaxsbGqtMPDQ8OBJKltbW2VIhrQ4uIiubm5ClLCoQ9IFJGK29zcVHvhjRWSqpDqkEqzsbFB3FUXSHxEzFEmiYuL01v2lZWVpKWlKW8SINnHZDOWvLr2XhYdHa3MS7YNSWwxRi2HZMUyoHhPSkoKXl5eeoFiY2OZnp5WvtTQ0KDekaKQ3ysrK9czRjHDzs5OZF96/vy5WqHkiyi1vr6ujg/ixGtra2pLkFXL8UNbvdwTW8jIyKCkpESpK4URGhrKq1evqK6uVruA9Om06+/2V52sbqn/HugqIe8V+iKFbIG/AYur3vpK/XLs9AbmtH+ucv0VCP5KE1417B/AL8C+7tcPUSkT+AG4eFC+ajjD+g+Bzv++LVz4HGPYsLf09p37gvYPFQl+Q0BOypkAAAAASUVORK5CYII=", "visible": true, "tab_version": "3.0.1", "tab_build_no": "2", "build_no": 1}, "data_input_builder": {"datainputs": [{"index": "default", "sourcetype": "json", "interval": "30", "use_external_validation": true, "streaming_mode_xml": true, "name": "ck_module", "title": "ck_module", "description": "", "type": "customized", "parameters": [{"name": "username", "label": "Username (chainkit)", "help_string": "", "required": true, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": "btest8"}, {"name": "password", "label": "Password", "help_string": "", "required": true, "format_type": "password", "default_value": "", "placeholder": "", "type": "password", "value": "Pencil123456!"}, {"name": "storage", "label": "Storage", "help_string": "", "required": true, "possible_values": [{"value": "pencil", "label": "Pencil"}, {"value": "public", "label": "Ethereum"}, {"value": "private", "label": "Sawtooth"}, {"label": "VMware", "value": "concord"}], "format_type": "dropdownlist", "default_value": "pencil", "placeholder": "", "type": "dropdownlist", "value": "pencil"}, {"name": "api", "label": "API", "help_string": "", "required": true, "possible_values": [{"value": "register", "label": "Register"}, {"value": "verify", "label": "Verify"}], "format_type": "dropdownlist", "default_value": "", "placeholder": "", "type": "dropdownlist", "value": "verify"}, {"name": "search_name", "label": "Search_name", "help_string": "", "required": true, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": "test"}, {"name": "query", "label": "Query", "help_string": "", "required": true, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": "search index=\"ck_register\""}, {"name": "earliest_time", "label": "Earliest_time", "help_string": "", "required": true, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": "-60"}, {"name": "latest_time", "label": "Latest_time", "help_string": "", "required": true, "format_type": "text", "default_value": "", "placeholder": "", "type": "text", "value": "0"}, {"name": "global_account", "label": "Global Account", "help_string": "", "required": true, "possible_values": [], "format_type": "global_account", "default_value": "", "placeholder": "", "type": "global_account", "value": "account0"}, {"name": "export_logs", "label": "Export_Logs", "help_string": "It is not required for Verify API", "required": false, "possible_values": [{"value": "raw_data", "label": "Raw_data"}, {"value": "no_space", "label": "No_space"}], "format_type": "dropdownlist", "default_value": "raw_data", "placeholder": "", "type": "dropdownlist", "value": "raw_data"}], "data_inputs_options": [{"type": "customized_var", "name": "username", "title": "Username (chainkit)", "description": "", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "password", "title": "Password", "description": "", "required_on_edit": false, "required_on_create": true, "format_type": "password", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "storage", "title": "Storage", "description": "", "required_on_edit": false, "required_on_create": true, "possible_values": [{"value": "pencil", "label": "Pencil"}, {"value": "public", "label": "Ethereum"}, {"value": "private", "label": "Sawtooth"}, {"label": "VMware", "value": "concord"}], "format_type": "dropdownlist", "default_value": "pencil", "placeholder": ""}, {"type": "customized_var", "name": "api", "title": "API", "description": "", "required_on_edit": false, "required_on_create": true, "possible_values": [{"value": "register", "label": "Register"}, {"value": "verify", "label": "Verify"}], "format_type": "dropdownlist", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "search_name", "title": "Search_name", "description": "", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "query", "title": "Query", "description": "", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "earliest_time", "title": "Earliest_time", "description": "", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "latest_time", "title": "Latest_time", "description": "", "required_on_edit": false, "required_on_create": true, "format_type": "text", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "global_account", "title": "Global Account", "description": "", "required_on_edit": false, "required_on_create": true, "possible_values": [], "format_type": "global_account", "default_value": "", "placeholder": ""}, {"type": "customized_var", "name": "export_logs", "title": "Export_Logs", "description": "It is not required for Verify API", "required_on_edit": false, "required_on_create": false, "possible_values": [{"value": "raw_data", "label": "Raw_data"}, {"value": "no_space", "label": "No_space"}], "format_type": "dropdownlist", "default_value": "raw_data", "placeholder": ""}], "code": "\n# encoding = utf-8\n\nimport os\nimport sys\nimport time\nimport datetime\nimport json\nfrom splunklib import client, results\nfrom datetime import datetime, timedelta\nimport requests\nimport hashlib\n\n'''\n    IMPORTANT\n    Edit only the validate_input and collect_events functions.\n    Do not edit any other part in this file.\n    This file is generated only once when creating the modular input.\n'''\n'''\n# For advanced users, if you want to create single instance mod input, uncomment this method.\ndef use_single_instance_mode():\n    return True\n'''\n\ndef validate_input(helper, definition):\n    \"\"\"Implement your own validation logic to validate the input stanza configurations\"\"\"\n    # This example accesses the modular input variable\n    # username = definition.parameters.get('username', None)\n    # password = definition.parameters.get('password', None)\n    # storage = definition.parameters.get('storage', None)\n    # api = definition.parameters.get('api', None)\n    pass\n\ndef collect_events(helper, ew):\n    \"\"\"Implement your data collection logic here\n\n    # The following examples get the arguments of this input.\n    # Note, for single instance mod input, args will be returned as a dict.\n    # For multi instance mod input, args will be returned as a single value.\n    opt_username = helper.get_arg('username')\n    opt_password = helper.get_arg('password')\n    opt_storage = helper.get_arg('storage')\n    opt_api = helper.get_arg('api')\n    # In single instance mode, to get arguments of a particular input, use\n    opt_username = helper.get_arg('username', stanza_name)\n    opt_password = helper.get_arg('password', stanza_name)\n    opt_storage = helper.get_arg('storage', stanza_name)\n    opt_api = helper.get_arg('api', stanza_name)\n\n    # get input type\n    helper.get_input_type()\n\n    # The following examples get input stanzas.\n    # get all detailed input stanzas\n    helper.get_input_stanza()\n    # get specific input stanza with stanza name\n    helper.get_input_stanza(stanza_name)\n    # get all stanza names\n    helper.get_input_stanza_names()\n\n    # The following examples get options from setup page configuration.\n    # get the loglevel from the setup page\n    loglevel = helper.get_log_level()\n    # get proxy setting configuration\n    proxy_settings = helper.get_proxy()\n    # get account credentials as dictionary\n    account = helper.get_user_credential_by_username(\"username\")\n    account = helper.get_user_credential_by_id(\"account id\")\n    # get global variable configuration\n    global_userdefined_global_var = helper.get_global_setting(\"userdefined_global_var\")\n\n    # The following examples show usage of logging related helper functions.\n    # write to the log for this modular input using configured global log level or INFO as default\n    helper.log(\"log message\")\n    # write to the log using specified log level\n    helper.log_debug(\"log message\")\n    helper.log_info(\"log message\")\n    helper.log_warning(\"log message\")\n    helper.log_error(\"log message\")\n    helper.log_critical(\"log message\")\n    # set the log level for this modular input\n    # (log_level can be \"debug\", \"info\", \"warning\", \"error\" or \"critical\", case insensitive)\n    helper.set_log_level(log_level)\n\n    # The following examples send rest requests to some endpoint.\n    response = helper.send_http_request(url, method, parameters=None, payload=None,\n                                        headers=None, cookies=None, verify=True, cert=None,\n                                        timeout=None, use_proxy=True)\n    # get the response headers\n    r_headers = response.headers\n    # get the response body as text\n    r_text = response.text\n    # get response body as json. If the body text is not a json string, raise a ValueError\n    r_json = response.json()\n    # get response cookies\n    r_cookies = response.cookies\n    # get redirect history\n    historical_responses = response.history\n    # get response status code\n    r_status = response.status_code\n    # check the response status, if the status is not sucessful, raise requests.HTTPError\n    response.raise_for_status()\n\n    # The following examples show usage of check pointing related helper functions.\n    # save checkpoint\n    helper.save_check_point(key, state)\n    # delete checkpoint\n    helper.delete_check_point(key)\n    # get checkpoint\n    state = helper.get_check_point(key)\n\n    # To create a splunk event\n    helper.new_event(data, time=None, host=None, index=None, source=None, sourcetype=None, done=True, unbroken=True)\n    \"\"\"\n\n    '''\n    # The following example writes a random number as an event. (Multi Instance Mode)\n    # Use this code template by default.\n    import random\n    data = str(random.randint(0,100))\n    event = helper.new_event(source=helper.get_input_type(), index=helper.get_output_index(), sourcetype=helper.get_sourcetype(), data=data)\n    ew.write_event(event)\n    '''\n\n    '''\n    # The following example writes a random number as an event for each input config. (Single Instance Mode)\n    # For advanced users, if you want to create single instance mod input, please use this code template.\n    # Also, you need to uncomment use_single_instance_mode() above.\n    import random\n    input_type = helper.get_input_type()\n    for stanza_name in helper.get_input_stanza_names():\n        data = str(random.randint(0,100))\n        event = helper.new_event(source=input_type, index=helper.get_output_index(stanza_name), sourcetype=helper.get_sourcetype(stanza_name), data=data)\n        ew.write_event(event)\n    '''\n    opt_username = helper.get_arg('username')\n    opt_password = helper.get_arg('password')\n    opt_storage = helper.get_arg('storage')\n    opt_api = helper.get_arg('api')\n    opt_search_name = helper.get_arg(\"search_name\")\n    opt_query = helper.get_arg(\"query\")\n    opt_earliest_time = int(helper.get_arg(\"earliest_time\"))\n    opt_latest_time = int(helper.get_arg(\"latest_time\"))\n    # Splunk Account\n    opt_global_account = helper.get_arg(\"global_account\")\n    opt_export_logs = helper.get_arg(\"export_logs\")\n    \n    data = opt_username\n    res = {}\n\n    proxy_settings = helper.get_proxy()\n    \n    \n    username = opt_global_account.get(\"username\")\n    password = opt_global_account.get(\"password\")\n    \n    HOST = os.getenv(\"SPLUNK_HOST\", \"localhost\")\n    PORT = int(os.getenv(\"SPLUNK_PORT\", \"8089\"))\n    now = datetime.now()\n    now = now - timedelta(seconds=now.second)\n    service = client.connect(\n        host=HOST,\n        port=PORT,\n        username=username,\n        password=password)\n    \n    earliest_time = (now - timedelta(seconds=-opt_earliest_time)).strftime(\n        '%Y-%m-%dT%H:%M:%S')\n    latest_time = (now - timedelta(seconds=-opt_latest_time)).strftime('%Y-%m-%dT%H:%M:%S')\n    \n    kwargs_export = {\"earliest_time\": earliest_time,\n                     \"latest_time\": latest_time,\n                     \"search_mode\": \"normal\",\n                     \"preview\": False}\n    \n    exportsearch_results = service.jobs.export(str(opt_query), **kwargs_export)\n    \n    reader = results.ResultsReader(exportsearch_results)\n    \n    logs = []\n    \n    if opt_api == \"register\":\n\n        for result in reader:\n            if isinstance(result, dict):\n                logs += [list(result)]\n        \n        logs.sort()\n        length = len(logs)\n        if opt_export_logs == \"raw_data\":\n            logs = str(logs)\n        elif opt_export_logs == \"no_space\":\n            logs = str(logs).replace(\" \", \"\")\n        _hash = make_hash(logs)\n\n        logindata = login(opt_username, opt_password)\n        entityId = register(logindata, _hash, opt_storage)\n        \n        res = {}\n\n        res[\"hash\"] = str(_hash)\n        res[\"query\"] = opt_query\n        res[\"title\"] = opt_search_name\n        _time = (datetime.now()).strftime('%Y-%m-%dT%H:%M:%S')\n        res[\"running_script\"] = _time\n        res[\"assetId\"] = entityId.get(\"assetId\")\n        res[\"earliest_time\"] = earliest_time\n        res[\"latest_time\"] = latest_time\n        res[\"length\"] = length\n        res[\"export_logs\"] = opt_export_logs\n        \n        _event = helper.new_event(source=helper.get_input_type(), index=helper.get_output_index(), sourcetype=helper.get_sourcetype(), data=json.dumps(res))\n        ew.write_event(_event)\n        \n        \n    if opt_api == \"verify\":\n        \n        for result in reader:\n            \n            if isinstance(result, dict):\n                \n                dict_res = result[\"_raw\"]\n                dict_res = json.loads(dict_res)\n                \n                assetId = dict_res[\"assetId\"]\n                earliest_time = dict_res[\"earliest_time\"]\n                latest_time = dict_res[\"latest_time\"]\n                query_hash = dict_res[\"query\"]\n                title = dict_res[\"title\"]\n                export_logs = dict_res[\"export_logs\"]\n                reg_time = result[\"_time\"]\n                \n                kwargs_export = {\"earliest_time\": earliest_time,\n                                 \"latest_time\": latest_time,\n                                 \"search_mode\": \"normal\",\n                                 \"preview\": False\n                                 }\n                \n                searchquery_export = query_hash\n                \n                exportsearch_results = service.jobs.export(str(searchquery_export), **kwargs_export)\n                reader = results.ResultsReader(exportsearch_results)\n                logs =[]\n                for result in reader:\n                    if isinstance(result, dict):\n                        logs += [list(result)]\n\n                \n                logs.sort()\n                length = len(logs)\n                if export_logs == \"raw_data\":\n                    logs = str(logs)\n                elif export_logs == \"no_space\":\n                    logs = str(logs).replace(\" \", \"\")\n                _hash = make_hash(logs)\n                \n                logindata = login(opt_username, opt_password)\n                response = verify(logindata, assetId, _hash, opt_storage)\n                verified = response.get(\"verified\")\n                res = {}\n                res[\"run_script\"] = (datetime.now()).strftime('%Y-%m-%dT%H:%M:%S')\n                res[\"verified\"] = verified\n                res[\"assetId\"] = assetId\n                res[\"earliest_time\"] = earliest_time\n                res[\"latest_time\"] = latest_time\n                res[\"hash\"] = _hash\n                res[\"query\"] = query_hash\n                res[\"title\"] = title\n                res[\"reg_time\"] = reg_time\n                res[\"length\"] = length\n                res[\"export_logs\"] = export_logs\n                \n                event = helper.new_event(source=helper.get_input_type(), index=helper.get_output_index(), sourcetype=helper.get_sourcetype(), data=json.dumps(res))\n                ew.write_event(event)\n\n\ndef login(username, password):\n    \"\"\"Construct an ProvenanceValidator object by logging in to the\n    Pencildata server.\n       Both the username and the password arguments may be given as str.\n       Password bytes sequence will be submitted to the server encoded in\n    base64. After a successful authentication, the login_data property is\n    populated by a dictionary that (among other things) contains the\n    user's AccessToken. If the authentication fails, an exception is raised\n    (actually a HTTPError: Bad Request).\"\"\"\n\n    url = 'https://api.pencildata.com/token'\n    data = {'userId': username, 'password': password}\n    head = {\"Content-Type\": \"application/json\"}\n    res = requests.request(\"POST\", url, data=json.dumps(data), headers=head)\n\n    return res.json()\n    \ndef make_hash(val):\n    hash_object = hashlib.sha256()\n    hash_object.update(val.encode('utf-8'))\n    return hash_object.hexdigest()\n\n### This function is to register hash to blockchain\ndef register(login_data, hash, storage=\"pencil\"):\n    \"\"\"Register a file (by its SHA-256 hash) in your Pencildata account.\n    Warning: this method does not check if the file hash exists in the\n    registers. It returns the asset id for the file.\n\n    Arguments:\n    login_data: Access Token\n    storage: 'public' or 'private'. Whether to store the file entry in the\n    public or in the private database at the PencilDATA server.\"\"\"\n\n    datajson = {}\n\n    datajson[\"hash\"] = hash\n    datajson[\"storage\"] = storage\n    url = \"https://api.pencildata.com/register/\"\n\n    head = {\"Content-Type\": \"application/json\",\n            \"Authorization\": \"Bearer {0}\".format(login_data['data']['accessToken'])}  # Request HTTP headers\n    res = requests.request(\"POST\", url, data=json.dumps(datajson), headers=head)\n\n    return res.json()\n\n### This function is to verify hash against hash in blockchain\ndef verify(login_data, asset_id, hash, storage=\"pencil\"):\n    \"\"\"Register a file (by its SHA-256 hash) in your Pencildata account.\n    Warning: this method does not check if the file hash exists in the\n    registers. It returns the asset id for the file.\n\n    Arguments:\n    file: file name or a file object. If file is given as a file-like\n    object, this method advances the current position of the file until\n    its end, but it does not close the file-like object\n    storage: 'public' or 'private'. Whether to store the file entry in the\n    public or in the private database at the PencilDATA server.\"\"\"\n    datajson = {}\n    datajson[\"hash\"] = hash\n    datajson[\"storage\"] = storage\n    url = \"https://api.pencildata.com/verify/\" + str(asset_id)\n    head = {\"Content-Type\": \"application/json\",\n            \"Authorization\": \"Bearer {0}\".format(login_data['data']['accessToken'])}  # Request HTTP headers\n    res = requests.request(\"GET\", url, params=datajson, headers=head)\n    return res.json()\n\n\n", "customized_options": [{"name": "username", "value": "btest8"}, {"name": "storage", "value": "pencil"}, {"name": "api", "value": "verify"}, {"name": "search_name", "value": "test"}, {"name": "query", "value": "search index=\"ck_register\""}, {"name": "earliest_time", "value": "-60"}, {"name": "latest_time", "value": "0"}, {"name": "global_account", "value": "account0"}, {"name": "export_logs", "value": "raw_data"}], "uuid": "72246d6a1f07411a892f1d96f4bdd1b6", "sample_count": "271"}]}, "field_extraction_builder": {"json": {"data_format": "json"}}, "global_settings_builder": {"global_settings": {"log_settings": {"log_level": "DEBUG"}, "credential_settings": [], "customized_settings": [{"required": true, "name": "username", "label": "username", "default_value": "", "placeholder": "", "help_string": "", "type": "text", "format_type": "text", "value": "demo"}, {"required": true, "name": "password", "label": "Password", "placeholder": "", "default_value": "", "help_string": "", "type": "password", "format_type": "password", "value": ""}]}}, "sourcetype_builder": {"json": {"metadata": {"event_count": 0, "data_input_name": "ck_module", "extractions_count": 0, "cims_count": 0}}}, "validation": {"validators": ["best_practice_validation", "data_model_mapping_validation", "field_extract_validation", "app_cert_validation"], "status": "job_finished", "validation_id": "v_1591674531_89", "progress": 1.0}}